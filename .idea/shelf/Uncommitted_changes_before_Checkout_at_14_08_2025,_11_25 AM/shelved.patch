Index: .idea/misc.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+><?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<project version=\"4\">\n  <component name=\"Black\">\n    <option name=\"sdkName\" value=\"Python 3.12 (dashboard_backend)\" />\n  </component>\n  <component name=\"ProjectRootManager\" version=\"2\" project-jdk-name=\"Python 3.13\" project-jdk-type=\"Python SDK\" />\n</project>
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/.idea/misc.xml b/.idea/misc.xml
--- a/.idea/misc.xml	(revision e6be093f8c9b4cb3cb0f8b9bb15fff6babdd5844)
+++ b/.idea/misc.xml	(date 1754223681322)
@@ -3,5 +3,5 @@
   <component name="Black">
     <option name="sdkName" value="Python 3.12 (dashboard_backend)" />
   </component>
-  <component name="ProjectRootManager" version="2" project-jdk-name="Python 3.13" project-jdk-type="Python SDK" />
+  <component name="ProjectRootManager" version="2" project-jdk-name="Python 3.12 (SMSC_Project_Dashboard_Backend)" project-jdk-type="Python SDK" />
 </project>
\ No newline at end of file
Index: .idea/dashboard_backend.iml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+><?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<module type=\"PYTHON_MODULE\" version=\"4\">\n  <component name=\"Flask\">\n    <option name=\"enabled\" value=\"true\" />\n  </component>\n  <component name=\"NewModuleRootManager\">\n    <content url=\"file://$MODULE_DIR$\">\n      <excludeFolder url=\"file://$MODULE_DIR$/.venv\" />\n      <excludeFolder url=\"file://$MODULE_DIR$/venv\" />\n    </content>\n    <orderEntry type=\"jdk\" jdkName=\"Python 3.13\" jdkType=\"Python SDK\" />\n    <orderEntry type=\"sourceFolder\" forTests=\"false\" />\n    <orderEntry type=\"module\" module-name=\"dashboard_prediction\" />\n  </component>\n  <component name=\"TemplatesService\">\n    <option name=\"TEMPLATE_CONFIGURATION\" value=\"Jinja2\" />\n    <option name=\"TEMPLATE_FOLDERS\">\n      <list>\n        <option value=\"$MODULE_DIR$/templates\" />\n      </list>\n    </option>\n  </component>\n</module>
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/.idea/dashboard_backend.iml b/.idea/dashboard_backend.iml
--- a/.idea/dashboard_backend.iml	(revision e6be093f8c9b4cb3cb0f8b9bb15fff6babdd5844)
+++ b/.idea/dashboard_backend.iml	(date 1754223681320)
@@ -8,7 +8,7 @@
       <excludeFolder url="file://$MODULE_DIR$/.venv" />
       <excludeFolder url="file://$MODULE_DIR$/venv" />
     </content>
-    <orderEntry type="jdk" jdkName="Python 3.13" jdkType="Python SDK" />
+    <orderEntry type="jdk" jdkName="Python 3.12 (SMSC_Project_Dashboard_Backend)" jdkType="Python SDK" />
     <orderEntry type="sourceFolder" forTests="false" />
     <orderEntry type="module" module-name="dashboard_prediction" />
   </component>
Index: Routes/consolidatedRoutes.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>from flask import Blueprint, jsonify, request, abort\nfrom pymongo import MongoClient\nfrom dotenv import load_dotenv\nimport os, math\nfrom datetime import time\nfrom Helpers.helpers import parse_start_timestamp\n\nconsolidatedAPI = Blueprint('consolidated', __name__)\nload_dotenv()\n\nmongo_uri = os.getenv('MONGO_URI', 'mongodb://localhost:27017')\nclient = MongoClient(mongo_uri)\npower_db = client[\"power_casting_new\"]\n\n\n# ---------- Helpers ----------\ndef calculate_weighted_average_for_quantum(plants, quantum):\n    used_units = 0.0\n    total_cost = 0.0\n    total_units = 0.0\n    updated_plants = []\n\n    for plant in sorted(plants, key=lambda x: x['VC'], reverse=True):\n        available = plant.get('backdown_units', 0.0)\n        vc = plant.get('VC', 0.0)\n\n        if used_units >= quantum:\n            plant['used_for_quantum'] = 0.0\n            updated_plants.append(plant)\n            continue\n\n        use = min(quantum - used_units, available)\n        cost = use * vc\n\n        used_units += use\n        total_cost += cost\n        total_units += use\n\n        plant['used_for_quantum'] = use\n        updated_plants.append(plant)\n\n    weighted_avg = round(total_cost / total_units, 2) if total_units > 0 else 0.0\n    return weighted_avg, round(total_cost, 2), round(total_units, 2), updated_plants\n\n\ndef in_dsm_window(ts):\n    t = ts.time()\n    return (time(9, 0) <= t < time(11, 0)) or (time(18, 0) <= t < time(20, 0))\n\n\ndef fetch_banking_row(ts):\n    rec = power_db[\"banking_data\"].find_one({\"Timestamp\": ts}, {\"_id\": 0, \"banked_units\": 1, \"adjusted_units\": 1})\n    if not rec:\n        raise LookupError(f\"No banking_data for {ts}\")\n    bu = rec.get(\"banked_units\", 0.0) or 0.0\n    au = rec.get(\"adjusted_units\", 0.0) or 0.0\n    if math.isnan(bu): bu = 0.0\n    if math.isnan(au): au = 0.0\n    return bu, au\n\n\ndef fetch_plants(ts):\n    cursor = power_db[\"Plant_Generation\"].find(\n        {\"Timestamp\": ts}, {\"_id\": 0, \"Plant_Name\": 1, \"DC\": 1, \"SG\": 1, \"VC\": 1}\n    )\n    plants = []\n    for p in cursor:\n        dc = 0.0 if math.isnan(p.get(\"DC\", 0.0) or 0.0) else (p.get(\"DC\", 0.0) or 0.0)\n        sg = 0.0 if math.isnan(p.get(\"SG\", 0.0) or 0.0) else (p.get(\"SG\", 0.0) or 0.0)\n        vc = round(0.0 if math.isnan(p.get(\"VC\", 0.0) or 0.0) else (p.get(\"VC\", 0.0) or 0.0), 2)\n\n        bd_units = round(((dc - sg) * 1000 * 0.25) if dc > sg else 0.0, 2)\n        bd_cost = round(bd_units * vc if not math.isnan(bd_units * vc) else 0.0, 2)\n\n        plants.append({\n            \"Plant_Name\": p.get(\"Plant_Name\"),\n            \"DC\": dc, \"SG\": sg, \"VC\": vc,\n            \"backdown_units\": bd_units,\n            \"backdown_cost\": bd_cost\n        })\n    # Keep a copy sorted by VC for MOD\n    plants_by_vc = sorted(plants, key=lambda r: r[\"VC\"], reverse=True)\n    return plants, plants_by_vc\n\n\ndef fetch_demand_drawl(ts):\n    rec = power_db[\"Demand_Drawl\"].find_one(\n        {\"Timestamp\": ts}, {\"_id\": 0, \"Scheduled_Generation\": 1, \"Drawl\": 1}\n    )\n    if not rec:\n        raise LookupError(f\"No Demand_Drawl for {ts}\")\n    sg = rec.get(\"Scheduled_Generation\", 0.0) or 0.0\n    dr = rec.get(\"Drawl\", 0.0) or 0.0\n    return sg, dr\n\n\ndef fetch_market_prices(ts):\n    rec = power_db[\"market_price_data\"].find_one(\n        {\"Timestamp\": ts}, {\"_id\": 0, \"DAM\": 1, \"RTM\": 1, \"Market_Purchase\": 1}\n    )\n    if not rec:\n        raise LookupError(f\"No market_price_data for {ts}\")\n    dam = rec.get(\"DAM\", 0.0) or 0.0\n    rtm = rec.get(\"RTM\", 0.0) or 0.0\n    mp = rec.get(\"Market_Purchase\", 0.0) or 0.0\n    return dam, rtm, mp\n\n\ndef fetch_battery_status(ts):\n    # most recent at or before ts\n    doc = power_db[\"Battery_Status\"].find_one({\"Timestamp\": ts}, sort=[(\"Timestamp\", -1)])\n    if not doc:\n        doc = power_db[\"Battery_Status\"].find_one({\"Timestamp\": {\"$lt\": ts}}, sort=[(\"Timestamp\", -1)])\n    if not doc:\n        # initialize if missing\n        doc = {\"Units_Available\": 0.0, \"Cycle\": \"NO_CHARGE\"}\n    return doc\n\n\ndef upsert_battery_status(ts, qty, cycle, *, capacity_limit=None):\n    \"\"\"\n    qty: the energy amount for this action (positive).\n    Units_Available = free capacity to accept charge (headroom).\n      - CHARGE: consume headroom -> headroom -= qty\n      - USE   : free headroom    -> headroom += qty\n      - else  : unchanged\n    capacity_limit: optional maximum headroom, if you model total capacity.\n    \"\"\"\n    prev = fetch_battery_status(ts)\n    headroom = float(prev.get(\"Units_Available\", 0.0) or 0.0)\n\n    if cycle == \"CHARGE\":\n        headroom = max(headroom - qty, 0.0)\n    elif cycle == \"USE\":\n        headroom = headroom + qty\n        if capacity_limit is not None:\n            headroom = min(headroom, capacity_limit)\n    else:\n        # NO_CHARGE or anything else -> no change\n        pass\n\n    headroom = round(headroom, 3)\n    power_db[\"Battery_Status\"].update_one(\n        {\"Timestamp\": ts},\n        {\"$set\": {\"Units_Available\": headroom, \"Cycle\": cycle}},\n        upsert=True\n    )\n\n\n# ---------- Core calc ----------\ndef compute_totals(plants, plants_by_vc):\n    t_units = round(sum(p[\"backdown_units\"] for p in plants), 2)\n    t_cost = round(sum(p[\"backdown_cost\"] for p in plants), 2)\n    wav = round((t_cost / t_units), 2) if t_units > 0 else 0.0\n    mod = round(plants_by_vc[0][\"VC\"], 2) if plants_by_vc else 0.0\n    return t_units, t_cost, wav, mod\n\n\ndef decide_banking(timestamp, banked_units, scheduled_generation, drawl, weighted_average, mod, dam, rtm,\n                   market_purchase,\n                   total_backdown_units, total_backdown_cost, units_available_before, plants_by_vc):\n    if banked_units <= 0:\n        return {\n            \"banking_cost\": 0.0,\n            \"DSM_units\": 0.0,\n            \"cycle\": \"NO_CHARGE\",\n            \"units_available_after\": units_available_before,\n            \"weighted_average\": round(weighted_average, 2),\n            \"market_purchase\": 0\n        }\n\n    s_d = max(scheduled_generation - drawl, 0.0)  # schedule surplus\n    units_after = units_available_before\n    banking_cost = 0.0\n    market_purchase = 0\n    dsm_units = 0.0\n    weighted_average = weighted_average\n    cycle = \"NO_CHARGE\"\n\n    if s_d > 0:\n        if s_d >= banked_units:\n            if not in_dsm_window(timestamp):\n                cycle = \"CHARGE\"\n                banking_cost = 0.0\n                # added the banked unit to charge the battery\n                upsert_battery_status(timestamp, banked_units, cycle)\n            else:\n                # dsm all banked units\n                dsm_units = banked_units\n                cycle = \"USE\"\n                banking_cost = 0.0  # cost stays 0\n                upsert_battery_status(timestamp, banked_units, cycle)\n        else:\n            # s_d consumes part, rest are \"balanced_units\"\n            balanced_units = round(banked_units - s_d, 3)\n            cycle = \"NO_CHARGE\"\n            # your original logic for pricing balanced_units:\n            weighted_average, total_backdown_cost, total_backdown_units, updated_plants = calculate_weighted_average_for_quantum(\n                plants_by_vc, banked_units)\n            banking_cost = round(total_backdown_cost, 2)\n            if balanced_units >= total_backdown_units:\n                # Banking cost is total backdown cost + extra-unit which is purchased from market\n                market_purchase = balanced_units - total_backdown_units\n                banking_cost = round(total_backdown_cost + market_purchase * min(dam, rtm), 2)\n            upsert_battery_status(timestamp, banked_units, cycle)\n    else:\n        # sg <= drawl (no surplus)\n        if total_backdown_units < banked_units:\n            # If backdown units are less than banked units, total_backdown cost will be taken and remaining units will be purchased from market\n            cycle = \"NO_CHARGE\"\n            upsert_battery_status(timestamp, banked_units, cycle)\n            market_purchase = banked_units - total_backdown_units\n            banking_cost = round(total_backdown_cost + market_purchase * min(dam, rtm), 2)\n        else:\n            # If backdown units are greater than banked units, total_backdown quantity will be used to adjust the battery banking units\n            cycle = \"NO_CHARGE\"\n            upsert_battery_status(timestamp, banked_units, cycle)\n            # weighted average cost will be used to change the banking cost\n            weighted_average, total_backdown_cost, total_backdown_units, updated_plants = calculate_weighted_average_for_quantum(\n                plants_by_vc, banked_units)\n            banking_cost = round(weighted_average * banked_units, 2)\n\n    return {\n        \"banking_cost\": round(banking_cost, 2),\n        \"DSM_units\": round(dsm_units, 2),\n        \"cycle\": cycle,\n        \"units_available_after\": round(units_after, 3),\n        \"weighted_average\": round(weighted_average, 2),\n        \"market_purchase\": round(market_purchase, 2)\n    }\n\n\ndef compute_adjustment(timestamp, adjusted_units, mod, dam, rtm,\n                       battery_charge_rate=4.0):\n    highest_rate = max(mod, dam, rtm)\n    battery_status = fetch_battery_status(timestamp)\n    units_before = float(battery_status.get(\"Units_Available\", 0.0) or 0.0)\n    battery_used = 0.0\n    balance_units = 0.0\n    adj_cost = 0.0\n\n    # If there is no Adjusted Units\n    if adjusted_units <= 0:\n        return {\n            \"adjustment_charges\": 0.0,\n            \"battery_used\": 0.0,\n            \"balance_units\": 0.0,\n            \"units_available_after\": units_before,\n            \"highest_rate\": highest_rate,\n            \"battery_charge_rate\": 4.0\n        }\n\n    if in_dsm_window(timestamp):\n        if adjusted_units < units_before:\n            adj_cost = round(adjusted_units * battery_charge_rate, 2)\n            # this means that unit will be deducted from battery\n            cycle = \"USE\"\n            upsert_battery_status(timestamp, adjusted_units, cycle)\n            units_before = units_before - adjusted_units\n        else:\n            # if enough units not available for deduction from battery\n            balance_units = adjusted_units - units_before\n            cycle = \"USE\"\n            upsert_battery_status(timestamp, balance_units, cycle)\n            adj_cost = units_before * battery_charge_rate + balance_units * highest_rate\n\n    else:\n        adj_cost = round(adjusted_units * highest_rate, 2)\n\n    return {\n        \"adjustment_charges\": adj_cost,\n        \"battery_used\": round(battery_used, 3),\n        \"balance_units\": round(balance_units, 3),\n        \"units_available_after\": round(units_before, 3),\n        \"highest_rate\": highest_rate,\n        \"battery_charge_rate\": 4.0\n    }\n\n\n@consolidatedAPI.route('/calculate', methods=['GET'])\ndef calculate_consolidated():\n    raw = request.args.get('start_date')\n    try:\n        timestamp = parse_start_timestamp(raw)\n    except ValueError as e:\n        return abort(400, description=str(e))\n\n    try:\n        # Getting banked unit and adjusted units\n        banked_units, adjusted_units = fetch_banking_row(timestamp)\n        # Getting plants data\n        plants, plants_by_vc = fetch_plants(timestamp)\n        # Getting SG and Drawl\n        scheduled_generation, drawl = fetch_demand_drawl(timestamp)\n        # Getting DAM, RTM, Market Purchase\n        dam, rtm, market_purchase = fetch_market_prices(timestamp)\n        # Getting the Battery Details\n        battery_details = fetch_battery_status(timestamp)\n    except LookupError as e:\n        return abort(404, description=str(e))\n\n    # weighted_average, total_backdown_cost, total_backdown_units, updated_plants = calculate_weighted_average_for_quantum(plants_by_vc, banked_units)\n    total_backdown_units, total_backdown_cost, weighted_average, mod = compute_totals(plants, plants_by_vc)\n    units_left_to_charge = float(battery_details.get(\"Units_Available\", 0.0) or 0.0)\n\n    # 1) Banking (may change battery)\n    bank = decide_banking(\n        timestamp, banked_units, scheduled_generation, drawl, weighted_average, mod, dam, rtm, market_purchase,\n        total_backdown_units, total_backdown_cost, units_left_to_charge, plants_by_vc\n    )\n\n    # 2) Adjustment (uses post-banking battery)\n    adj = compute_adjustment(\n        timestamp, adjusted_units, mod, dam, rtm,\n    )\n\n    return jsonify({\n        \"Timestamp\": timestamp.strftime(\"%Y-%m-%d %H:%M\"),\n\n        # Inputs\n        \"banked_units\": round(banked_units, 3),\n        \"adjusted_units\": round(adjusted_units, 3),\n        \"schedule_generation\": round(scheduled_generation, 3),\n        \"total_drawl\": round(drawl, 3),\n        \"dam_rate\": round(dam, 2),\n        \"rtm_rate\": round(rtm, 2),\n\n        # Plant & totals\n        \"plant_backdown_data\": plants,\n        \"total_backdown_units\": round(total_backdown_units, 3),\n        \"total_backdown_cost\": round(total_backdown_cost, 2),\n        \"weighted_avg_rate\": round(bank[\"weighted_average\"], 2),\n        \"MOD_rate\": mod,\n        \"highest_rate\": max(mod, dam, rtm),\n\n        # Banking result\n        \"banking_cost\": bank[\"banking_cost\"],\n        \"DSM\": bank[\"DSM_units\"],\n        \"banking_cycle\": bank[\"cycle\"],\n\n        # Adjustment result\n        \"adjustment_charges\": adj[\"adjustment_charges\"],\n        \"battery_units_used_for_adjustment\": adj[\"battery_used\"],\n        \"market_purchase\": adj[\"balance_units\"] + bank[\"market_purchase\"],\n        \"battery_charge_rate\": adj[\"battery_charge_rate\"],\n\n        # Battery snapshot\n        \"battery_units_before\": units_left_to_charge,\n        \"battery_units_after_banking\": bank[\"units_available_after\"],\n        \"battery_units_after_adjustment\": adj[\"units_available_after\"]\n    }), 200\n
===================================================================
diff --git a/Routes/consolidatedRoutes.py b/Routes/consolidatedRoutes.py
--- a/Routes/consolidatedRoutes.py	(revision e6be093f8c9b4cb3cb0f8b9bb15fff6babdd5844)
+++ b/Routes/consolidatedRoutes.py	(date 1754323231253)
@@ -347,5 +347,6 @@
         # Battery snapshot
         "battery_units_before": units_left_to_charge,
         "battery_units_after_banking": bank["units_available_after"],
+        "banked_bess:": units_left_to_charge - bank["units_available_after"],
         "battery_units_after_adjustment": adj["units_available_after"]
     }), 200
